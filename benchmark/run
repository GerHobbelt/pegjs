#!/usr/bin/env node

var util = require("util");
var fs   = require("fs");
var PEG  = require("../lib/peg");
var statistics = require("../lib/statistics");

[
  "benchmarks.js",
  "runner.js",
].forEach(function(file) {
  eval(fs.readFileSync(__dirname + "/" + file, "utf8"));
});

/* Results Table Manipulation */

function dup(text, count) {
  var result = "";
  for (var i = 1; i <= count; i++) {
    result += text;
  }
  return result;
}

function padLeft(text, length) {
  return dup(" ", length - text.length) + text;
}

function padRight(text, length) {
  return text + dup(" ", length - text.length);
}

function center(text, length) {
  var padLength = (length - text.length) / 2;
  return dup(" ", Math.floor(padLength))
    + text
    + dup(" ", Math.ceil(padLength));
}

function writeTableHeader() {
  util.puts("┌─────────────────────────────────────┬───────────┬────────────┬──────────────┐");
  util.puts("│                Test                 │ Inp. size │ Avg. time  │  Avg. speed  │");
}

function writeHeading(heading, options) {
  var extra = [""];
  if (options.optimize) {
    extra.push("O:" + options.optimize.toUpperCase());
  }
  if (options.cache) {
    extra.push("CACHE");
  }
  if (options.includeRegionInfo) {
    extra.push("REGIONINFO");
  }
  extra = extra.join(" +");
  heading += extra;

  util.puts("├─────────────────────────────────────┴───────────┴────────────┴──────────────┤");
  util.puts("│ " + center(heading, 75) + " │");
  util.puts("├─────────────────────────────────────┬───────────┬────────────┬──────────────┤");
}

function writeResult(title, inputSize, parseTime) {
  var KB      = 1024;
  var MS_IN_S = 1000;

  util.puts("│ "
    + padRight(title, 35)
    + " │ "
    + padLeft((inputSize / KB).toFixed(2), 6)
    + " kB │ "
    + padLeft(parseTime.toFixed(2), 7)
    + " ms │ "
    + padLeft(((inputSize / KB) / (parseTime / MS_IN_S)).toFixed(2), 7)
    + " kB/s │"
  );
}

function writeSeparator() {
  util.puts("├─────────────────────────────────────┼───────────┼────────────┼──────────────┤");
}

function writeTableFooter() {
  util.puts("└─────────────────────────────────────┴───────────┴────────────┴──────────────┘");
}

/* Helpers */

function printHelp() {
  util.puts("Usage: run [options]");
  util.puts("");
  util.puts("Runs PEG.js benchmark suite.");
  util.puts("");
  util.puts("Options:");
  util.puts("  -n, --run-count <n>          number of runs (default: 10)");
  util.puts("      --cache                  make tested parsers cache results");
  util.puts("      --includeRegionInfo      make tested parsers add region info to each AST node");
  util.puts("      --statistics             make tested parsers collect run-time statistics");
  util.puts("  -o, --optimize <goal>        select optimization for speed or size (default:");
  util.puts("                               speed)");
}

function exitSuccess() {
  process.exit(0);
}

function exitFailure() {
  process.exit(1);
}

function abort(message) {
  util.error(message);
  exitFailure();
}

/* Arguments */

var args = process.argv.slice(2); // Trim "node" and the script path.

function isOption(arg) {
  return (/^-/).test(arg);
}

function nextArg() {
  args.shift();
}

/* Main */

var runCount = 10;
var options = {
  cache:    0,
  collectRunTimeStatistics: 0,
  verboseOutput: false,
  optimize: "speed",
  plugins:  []
};

while (args.length > 0 && isOption(args[0])) {
  switch (args[0]) {
    case "-n":
    case "--run-count":
      nextArg();
      if (args.length === 0) {
        abort("Missing parameter of the -n/--run-count option.");
      }
      var runCount = parseInt(args[0], 10);
      if (isNaN(runCount) || runCount <= 0) {
        abort("Number of runs must be a positive integer.");
      }
      break;

    case "--cache":
      options.cache++;
      break;

    case "--includeRegionInfo":
      options.includeRegionInfo = true;
      break;

    case "--statistics":
      options.collectRunTimeStatistics++;
      break;

    case "-o":
    case "--optimize":
      nextArg();
      if (args.length === 0) {
        abort("Missing parameter of the -o/--optimize option.");
      }
      if (args[0] !== "speed" && args[0] !== "size") {
        abort("Optimization goal must be either \"speed\" or \"size\".");
      }
      options.optimize = args[0];
      break;

    case "-h":
    case "--help":
      printHelp();
      exitSuccess();
      break;

    default:
      abort("Unknown option: " + args[0] + ".");
  }
  nextArg();
}

if (args.length > 0) {
  abort("No arguments are allowed.");
}

Runner.run(benchmarks, {
  runCount: runCount,
  minimumRunTime: 250
}, options, {
  readFile: function(file) {
    return fs.readFileSync(__dirname + "/" + file, "utf8");
  },

  testStart: function(benchmark, test, state) {
    /* Nothing to do. */
  },

  testOneRound: function(benchmark, test, iterationIndex, parseTime, state) {
    /* Nothing to do. */
  },

  testFinish: function(benchmark, test, inputSize, parseTime, state) {
    var title = test.title;

    if (state.testFailCollection.length > 0) {
      // grab the first failure and report it:
      var firstFailure = state.testFailCollection[0];

      title += " !FAILED!";

      var ex = firstFailure.failure;
      var errMsg = ex.message;
      var locInfo = "";
      if (ex.line || ex.column || ex.offset) {
        locInfo = " (line: " + ex.line + ", column: " + ex.column + " ~ offset: " + ex.offset + ")";
      }
      var errPreMsg = "";
      if (ex.name) {
        errPreMsg = ex.name + ": ";
      }
      var msg = errPreMsg + errMsg + locInfo;
      util.puts(msg.trim() + "\n");
    }
    writeResult(title, inputSize, parseTime);
  },

  benchmarkStart: function(benchmark, state) {
    writeHeading(benchmark.title, options);
  },

  benchmarkFinish: function(benchmark, inputSize, parseTime, state) {
    writeSeparator();
    writeResult(benchmark.title + " total", inputSize, parseTime);

    if (options.collectRunTimeStatistics && PEG.parser && PEG.parser.getStatistics) {
      statistics.report(PEG.parser.getStatistics(), options);
    }
 },

  start: function(state) {
    writeTableHeader();
  },

  finish: function(inputSize, parseTime, state) {
    writeSeparator();
    writeResult("Total", inputSize, parseTime);
    writeTableFooter();
  },
});
