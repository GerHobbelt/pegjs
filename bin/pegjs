#!/usr/bin/env node
"use strict";

var fs   = require("fs");
var path = require("path");
var PEG  = require("../lib/peg");
var statistics = require("../lib/statistics");

var options;

/* Helpers */

function printVersion() {
  console.log("PEG.js " + PEG.VERSION);
}

function printHelp() {
  console.log("Usage: pegjs [options] [--] [<input_file>] [<output_file>]");
  console.log("");
  console.log("Generates a parser from the PEG grammar specified in the <input_file> and writes");
  console.log("it to the <output_file>.");
  console.log("");
  console.log("If the <output_file> is omitted, its name is generated by changing the");
  console.log("<input_file> extension to \".js\". If both <input_file> and <output_file> are");
  console.log("omitted, standard input and output are used.");
  console.log("");
  console.log("Options:");
  console.log("  -w, --watch                        watching a file, rebuild while modified.");
  console.log("  -e, --export-var <variable>        name of the variable where the parser");
  console.log("                                     object will be stored (default:");
  console.log("                                     \"PEG\")");
  console.log("      --cache                        make generated parser cache results");
  console.log("      --allowed-start-rules <rules>  comma-separated list of rules the generated");
  console.log("                                     parser will be allowed to start parsing");
  console.log("                                     from (default: the first rule in the");
  console.log("                                     grammar)");
  console.log("  -o, --optimize <goal>              select optimization for speed or size");
  console.log("                                     (default: speed)");
  console.log("      --trace                        enable tracing in generated parser");
  console.log("      --plugin <plugin>              use a specified plugin (can be specified");
  console.log("                                     multiple times)");
  console.log("      --extra-options <options>      additional options (in JSON format) to pass");
  console.log("                                     to PEG.buildParser");
  console.log("      --extra-options-file <file>    file with additional options (in JSON");
  console.log("                                     format) to pass to PEG.buildParser");
  console.log("      --statistics                   generate a parser which will collect");
  console.log("                                     run-time statistics while parsing any inputs");
  console.log("      --verbose                      verbose output, including parser diagnostics");
  console.log("      --elapsed-time                 report the time it took to build the parser");
  console.log("  -v, --version                      print version information and exit");
  console.log("  -h, --help                         print help and exit");
}

function exitSuccess() {
  process.exit(0);
}

function exitFailure() {
  process.exit(1);
}

function abort(message, ex) {
  console.error(message);
  if (options.verboseOutput && ex && ex.stack) {
    console.error("Stacktrace:\n", ex.stack);
  }
  exitFailure();
}

function addExtraOptions(options, json) {
  var extraOptions;

  try {
    extraOptions = JSON.parse(json);
  } catch (e) {
    if (!(e instanceof SyntaxError)) { throw e; }

    abort("Error parsing JSON: " + e.message, e);
  }
  if (typeof extraOptions !== "object") {
    abort("The JSON with extra options has to represent an object.");
  }

  for (var key in extraOptions) {
    if (extraOptions.hasOwnProperty(key)) {
      options[key] = extraOptions[key];
    }
  }
}

/*
 * Extracted into a function just to silence JSHint complaining about creating
 * functions in a loop.
 */
function trim(s) {
  return s.trim();
}

/* Arguments */

var args = process.argv.slice(2); // Trim "node" and the script path.

function isOption(arg) {
  return (/^-/).test(arg);
}

function nextArg() {
  args.shift();
}


/* Main */

/* This makes the generated parser a CommonJS module by default. */
options = {
  cache:    0,
  collectRunTimeStatistics: 0,
  verboseOutput: false,
  output:   "source",
  optimize: "speed",
  trace:    false,
  plugins:  []
};

while (args.length > 0 && isOption(args[0])) {
  switch (args[0]) {
    case "-w":
    case "--watch":
      if (args.length < 3 || args.length > 3) {
        abort("Argument should be 2, input and output file.");
      }
      console.log('watching file...' + args[1]);
      watchFile(args[1], args[2]);
      break;

    case "-e":
    case "--export-var":
      nextArg();
      if (args.length === 0) {
        abort("Missing parameter of the -e/--export-var option.");
      }
      options.exportVar = args[0];
      break;

    case "--cache":
      options.cache++;
      break;

    case "--statistics":
      options.collectRunTimeStatistics++;
      break;

    case "--allowed-start-rules":
      nextArg();
      if (args.length === 0) {
        abort("Missing parameter of the -e/--allowed-start-rules option.");
      }
      options.allowedStartRules = args[0]
        .split(",")
        .map(trim);
      break;

    case "--trace":
      options.trace = true;
      break;

    case "-o":
    case "--optimize":
      nextArg();
      if (args.length === 0) {
        abort("Missing parameter of the -o/--optimize option.");
      }
      if (args[0] !== "speed" && args[0] !== "size") {
        abort("Optimization goal must be either \"speed\" or \"size\".");
      }
      options.optimize = args[0];
      break;

    case "--plugin":
      nextArg();
      if (args.length === 0) {
        abort("Missing parameter of the --plugin option.");
      }
      var id = /^(\.\/|\.\.\/)/.test(args[0]) ? path.resolve(args[0]) : args[0];
      var mod;
      try {
        mod = require(id);
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND") { throw e; }

        abort("Can't load module \"" + id + "\".", e);
      }
      options.plugins.push(mod);
      break;

    case "--extra-options":
      nextArg();
      if (args.length === 0) {
        abort("Missing parameter of the --extra-options option.");
      }
      addExtraOptions(options, args[0]);
      break;

    case "--extra-options-file":
      nextArg();
      if (args.length === 0) {
        abort("Missing parameter of the --extra-options-file option.");
      }
      try {
        var json = fs.readFileSync(args[0]);
      } catch(e) {
        abort("Can't read from file \"" + args[0] + "\".");
      }
      addExtraOptions(options, json);
      break;

    case "--elapsed-time":
      options.reportElapsedTime = true;
      break;

    case "--verbose":
      options.verboseOutput = true;
      break;

    case "-v":
    case "--version":
      printVersion();
      exitSuccess();
      break;

    case "-h":
    case "--help":
      printHelp();
      exitSuccess();
      break;

    case "--":
      nextArg();
      break;

    default:
      abort("Unknown option: " + args[0] + ".");
  }
  nextArg();
}

switch (args.length) {
  case 0:
    process.stdin.resume();
    var inputStream = process.stdin;
    var outputStream = process.stdout;
    stream(inputStream, outputStream);
    break;

  case 1:
  case 2:
    rwFile(args[0], args[1], function(inputStream, outputStream) {
      stream(inputStream, outputStream);
    });
    break;

  default:
    abort("Too many arguments.");
}

function rwFile(input, output, cb) {
  var inputFile = input;
  var inputStream = fs.createReadStream(inputFile);
  inputStream.on("error", function() {
    abort("Can't read from file \"" + inputFile + "\".");
  });

  var outputFile = args.length === 1
    ? input.replace(/\.[^.]*$/, ".js")
    : output;
  var outputStream = fs.createWriteStream(outputFile);
  outputStream.on("error", function() {
    abort("Can't write to file \"" + outputFile + "\".");
  });

  cb(inputStream, outputStream);
}

/* Files */

function stream(inputStream, outputStream) {

  function readStream(inputStream, callback) {
    var input = "";
    inputStream.on("data", function(data) { input += data; });
    inputStream.on("end", function() { callback(input); });
  }

  readStream(inputStream, function(input) {
    var source;
    var startTime = new Date();

    try {
      source = PEG.buildParser(input, options);
    } catch (e) {
      if (e.location !== undefined) {
        abort(e.location.start.line + ":" + e.location.start.column + ": " + e.message, e);
      } else {
        abort(e.message, e);
      }
    }

    var endTime = new Date();
    var diffTime = (endTime - startTime) / 1000;
    if (options.reportElapsedTime) {
      console.log("Parser generated in " + diffTime + " seconds.");
    }

    if (options.collectRunTimeStatistics && PEG.parser && PEG.parser.getStatistics) {
      statistics.report(PEG.parser.getStatistics(), options);
    }

    outputStream.write(
      source + "\n"
    );
    if (outputStream !== process.stdout) {
      outputStream.end();
    }
  });
}

function watchFile(input, output) {
  fs.watchFile(input, function() {
    console.log(input + 'has been modified, rebuild pegjs ' + output);
    rwFile(input, output, function(inputStream, outputStream) {
      stream(inputStream, outputStream);
    });
  });
}

